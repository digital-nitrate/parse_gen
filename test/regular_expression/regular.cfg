%{
#include <stdlib.h>
#include "regular.h"

static int init_node(reg_nfa_table* table) {
	unsigned int* p = malloc((sizeof *p) * 16);
	if (p == NULL) return 1;
	int res = 0;
	DYNARR_CHK(table->node_cnt, table->node_cap, table->nodes, res);
	if (res) {free(p); return 1;}
	table->nodes[table->node_cnt].lambda = (reg_nfa_lam){.paths=p,.cnt=0,.cap=16};
	for (size_t i = 0; i < (1 << CHAR_BIT); ++i) {
		table->nodes[table->node_cnt].tran[i] = UINT_MAX;
	}
	++(table->node_cnt);
	return 0;
}

static int add_path(reg_nfa_node* node, unsigned int goal) {
	int res = 0;
	DYNARR_CHK(node->lambda.cnt, node->lambda.cap, node->lambda.paths, res);
	if (res) return 1;
	node->lambda.paths[node->lambda.cnt] = goal;
	++(node->lambda.cnt);
	return 0;
}

%}

%param <reg_nfa*> out
%param <void*> scanner

%token pipe 1
%token kleene 2
%token plus 3
%token open 4
%token close 5
%token <char> chara 6
%token dot 7
%token dash 8

%nterm RE
%nterm <reg_in> ALT
%nterm <struct reg_link*> ALTLIST
%nterm <reg_in> SEQ
%nterm <struct reg_link*> SEQLIST
%nterm <reg_in> ATOM
%nterm <enum atommod_type> ATOMMOD
%nterm <reg_in> NUCLEUS
%nterm <struct charrng> CHARRNG

%start RE

%%

RE:
	ALT %{out->specials = $1;%}
	;

ALT:
	SEQ ALTLIST %{
		if ($2 == NULL) {
			$$ = $1;
		} else {
			if (init_node(&(out->table))) exit(1);
			if (init_node(&(out->table))) exit(1);
			if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), $1.start)) exit(1);
			if (add_path(&(out->table.nodes[$1.end]), out->table.node_cnt - 1)) exit(1);
			struct reg_link* curr = $2;
			while (curr != NULL) {
				struct reg_link* tmp = curr;
				if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), tmp->sub.start)) exit(1);
				if (add_path(&(out->table.nodes[tmp->sub.end]), out->table.node_cnt - 1)) exit(1);
				curr = tmp->next;
				free(tmp);
			}
			$$.start = out->table.node_cnt - 2;
			$$.end = out->table.node_cnt - 1;
		}
	%}
	;

ALTLIST:
	pipe SEQ ALTLIST %{
		struct reg_link* top = malloc(sizeof *top);
		if (top == NULL) exit(1);
		top->next = $3;
		top->sub = $2;
		$$ = top;
	%}
	| %{$$ = NULL;%}
	;

SEQ:
	ATOM SEQLIST %{
		if ($2 == NULL) {
			$$ = $1;
		} else {
			if (init_node(&(out->table))) exit(1);
			if (init_node(&(out->table))) exit(1);
			if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), $1.start)) exit(1);
			unsigned int save = $1.end;
			struct reg_link* curr = $2;
			while (curr != NULL) {
				struct reg_link* tmp = curr;
				if (add_path(&(out->table.nodes[save]), tmp->sub.start)) exit(1);
				save = tmp->sub.end;
				curr = tmp->next;
				free(tmp);
			}
			if (add_path(&(out->table.nodes[save]), out->table.node_cnt - 1)) exit(1);
			$$.start = out->table.node_cnt - 2;
			$$.end = out->table.node_cnt - 1;
		}
	%}
	| %{
		if (init_node(&(out->table))) exit(1);
		if (init_node(&(out->table))) exit(1);
		if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), out->table.node_cnt - 1)) exit(1);
		$$.start = out->table.node_cnt - 2;
		$$.end = out->table.node_cnt - 1;
	%}
	;

SEQLIST:
	ATOM SEQLIST %{
		struct reg_link* top = malloc(sizeof *top);
		top->next = $2;
		top->sub = $1;
		$$ = top;
	%}
	| %{$$ = NULL;%}
	;

ATOM:
	NUCLEUS ATOMMOD %{
		if ($2 == MOD_NONE) {
			$$ = $1;
		} else {
			if (init_node(&(out->table))) exit(1);
			if (init_node(&(out->table))) exit(1);
			if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), $1.start)) exit(1);
			if (add_path(&(out->table.nodes[$1.end]), out->table.node_cnt - 1)) exit(1);
			if (add_path(&(out->table.nodes[$1.end]), $1.start)) exit(1);
			if ($2 == MOD_KLEENE) {
				if (add_path(&(out->table.nodes[$1.start]), $1.end)) exit(1);
			}
			$$.start = out->table.node_cnt - 2;
			$$.end = out->table.node_cnt - 1;
		}
	%}
	;

ATOMMOD:
	kleene %{$$ = MOD_KLEENE;%}
	| plus %{$$ = MOD_PLUS;%}
	| %{$$ = MOD_NONE;%}
	;

NUCLEUS:
	open ALT close %{$$ = $2;%}
	| chara CHARRNG %{
		if (init_node(&(out->table))) exit(1);
		if (init_node(&(out->table))) exit(1);
		if ($2.type == RNG_NONE) {
			out->table.nodes[out->table.node_cnt - 2].tran[(unsigned char)$1] = out->table.node_cnt - 1;
		} else {
			if ((unsigned char)$1 > (unsigned char)($2.top)) exit(1);
			for (size_t i = (unsigned char)$1; i <= (unsigned char)($2.top); ++i) {
				out->table.nodes[out->table.node_cnt - 2].tran[i] = out->table.node_cnt - 1;
			}
		}
		$$.start = out->table.node_cnt - 2;
		$$.end = out->table.node_cnt - 1;
	%}
	| dot %{
		if (init_node(&(out->table))) exit(1);
		if (init_node(&(out->table))) exit(1);
		for (size_t i = 0; i < (1 << CHAR_BIT); ++i) {
			out->table.nodes[out->table.node_cnt - 2].tran[i] = out->table.node_cnt - 1;
		}
		$$.start = out->table.node_cnt - 2;
		$$.end = out->table.node_cnt - 1;
	%}
	;

CHARRNG:
	dash chara %{
		$$.type = RNG_TOP;
		$$.top = $2;
	%}
	| %{$$.type = RNG_NONE;%}
	;

%%

extern int yylex(YYSTYPE* lvalp, reg_nfa* out, void* scanner);
