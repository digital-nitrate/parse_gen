/coderequires /{
	#include "regular.h"
/}

/codeprovides /{
	extern int yyparse(reg_nfa* out, void* scanner);
/}

/code /{
	#include <stdlib.h>
	#include "regex_lex.h"

	static int init_node(reg_nfa_table* table) {
		unsigned int* p = malloc((sizeof *p) * 16);
		if (p == NULL) return 1;
		int res = 0;
		DYNARR_CHK(table->node_cnt, table->node_cap, table->nodes, res);
		if (res) {free(p); return 1;}
		table->nodes[table->node_cnt].lambda = (reg_nfa_lam){.paths=p,.cnt=0,.cap=16};
		for (size_t i = 0; i < (1 << CHAR_BIT); ++i) {
			table->nodes[table->node_cnt].tran[i] = UINT_MAX;
		}
		++(table->node_cnt);
		return 0;
	}

	static int add_path(reg_nfa_node* node, unsigned int goal) {
		int res = 0;
		DYNARR_CHK(node->lambda.cnt, node->lambda.cap, node->lambda.paths, res);
		if (res) return 1;
		node->lambda.paths[node->lambda.cnt] = goal;
		++(node->lambda.cnt);
		return 0;
	}
/}

/parseparam <reg_nfa*> out
/parseparam <void*> scanner
/lexparam <void*> scanner

/token tokpipe 1
/token tokkleene 2
/token tokplus 3
/token tokopen 4
/token tokclose 5
/token <char> tokchar 6
/token tokdot 7
/token tokdash 8

/nterm NTRE
/nterm <reg_in> NTALT
/nterm <struct reg_link*> NTALTLIST
/nterm <reg_in> NTSEQ
/nterm <struct reg_link*> NTSEQLIST
/nterm <reg_in> NTATOM
/nterm <enum atommod_type> NTATOMMOD
/nterm <reg_in> NTNUCLEUS
/nterm <struct charrng> NTCHARRNG

/start NTRE

%%

NTRE:
	NTALT /{out->specials = $1;/}
	;

NTALT:
	NTSEQ NTALTLIST /{
		if ($2 == NULL) {
			$0 = $1;
		} else {
			if (init_node(&(out->table))) exit(1);
			if (init_node(&(out->table))) exit(1);
			if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), $1.start)) exit(1);
			if (add_path(&(out->table.nodes[$1.end]), out->table.node_cnt - 1)) exit(1);
			struct reg_link* curr = $2;
			while (curr != NULL) {
				struct reg_link* tmp = curr;
				if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), tmp->sub.start)) exit(1);
				if (add_path(&(out->table.nodes[tmp->sub.end]), out->table.node_cnt - 1)) exit(1);
				curr = tmp->next;
				free(tmp);
			}
			$0.start = out->table.node_cnt - 2;
			$0.end = out->table.node_cnt - 1;
		}
	/}
	;

NTALTLIST:
	tokpipe NTSEQ NTALTLIST /{
		struct reg_link* top = malloc(sizeof *top);
		if (top == NULL) exit(1);
		top->next = $3;
		top->sub = $2;
		$0 = top;
	/}
	| /empty /{$0 = NULL;/}
	;

NTSEQ:
	NTATOM NTSEQLIST /{
		if ($2 == NULL) {
			$0 = $1;
		} else {
			if (init_node(&(out->table))) exit(1);
			if (init_node(&(out->table))) exit(1);
			if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), $1.start)) exit(1);
			unsigned int save = $1.end;
			struct reg_link* curr = $2;
			while (curr != NULL) {
				struct reg_link* tmp = curr;
				if (add_path(&(out->table.nodes[save]), tmp->sub.start)) exit(1);
				save = tmp->sub.end;
				curr = tmp->next;
				free(tmp);
			}
			if (add_path(&(out->table.nodes[save]), out->table.node_cnt - 1)) exit(1);
			$0.start = out->table.node_cnt - 2;
			$0.end = out->table.node_cnt - 1;
		}
	/}
	| /empty /{
		if (init_node(&(out->table))) exit(1);
		if (init_node(&(out->table))) exit(1);
		if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), out->table.node_cnt - 1)) exit(1);
		$0.start = out->table.node_cnt - 2;
		$0.end = out->table.node_cnt - 1;
	/}
	;

NTSEQLIST:
	NTATOM NTSEQLIST /{
		struct reg_link* top = malloc(sizeof *top);
		top->next = $2;
		top->sub = $1;
		$0 = top;
	/}
	| /empty /{$0 = NULL;/}
	;

NTATOM:
	NTNUCLEUS NTATOMMOD /{
		if ($2 == MOD_NONE) {
			$0 = $1;
		} else {
			if (init_node(&(out->table))) exit(1);
			if (init_node(&(out->table))) exit(1);
			if (add_path(&(out->table.nodes[out->table.node_cnt - 2]), $1.start)) exit(1);
			if (add_path(&(out->table.nodes[$1.end]), out->table.node_cnt - 1)) exit(1);
			if (add_path(&(out->table.nodes[$1.end]), $1.start)) exit(1);
			if ($2 == MOD_KLEENE) {
				if (add_path(&(out->table.nodes[$1.start]), $1.end)) exit(1);
			}
			$0.start = out->table.node_cnt - 2;
			$0.end = out->table.node_cnt - 1;
		}
	/}
	;

NTATOMMOD:
	tokkleene /{$0 = MOD_KLEENE;/}
	| tokplus /{$0 = MOD_PLUS;/}
	| /empty /{$0 = MOD_NONE;/}
	;

NTNUCLEUS:
	tokopen NTALT tokclose /{$0 = $2;/}
	| tokchar NTCHARRNG /{
		if (init_node(&(out->table))) exit(1);
		if (init_node(&(out->table))) exit(1);
		if ($2.type == RNG_NONE) {
			out->table.nodes[out->table.node_cnt - 2].tran[(unsigned char)$1] = out->table.node_cnt - 1;
		} else {
			if ((unsigned char)$1 > (unsigned char)($2.top)) exit(1);
			for (size_t i = (unsigned char)$1; i <= (unsigned char)($2.top); ++i) {
				out->table.nodes[out->table.node_cnt - 2].tran[i] = out->table.node_cnt - 1;
			}
		}
		$0.start = out->table.node_cnt - 2;
		$0.end = out->table.node_cnt - 1;
	/}
	| tokdot /{
		if (init_node(&(out->table))) exit(1);
		if (init_node(&(out->table))) exit(1);
		for (size_t i = 0; i < (1 << CHAR_BIT); ++i) {
			out->table.nodes[out->table.node_cnt - 2].tran[i] = out->table.node_cnt - 1;
		}
		$0.start = out->table.node_cnt - 2;
		$0.end = out->table.node_cnt - 1;
	/}
	;

NTCHARRNG:
	tokdash tokchar /{
		$0.type = RNG_TOP;
		$0.top = $2;
	/}
	| /empty /{$0.type = RNG_NONE;/}
	;
